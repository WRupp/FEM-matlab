% Códigos para FEM Linear Elástico em EPD
% Fevereiro / 2018
% Wagner Rupp


clear; close all;
% Determina e adiciona todas as subfolders
folder = fileparts(which(mfilename)); 
addpath(genpath(folder));

%% Definição dos arquivos de entrada e saida

%Input
caminhoInput = 'C:\Users\Wagner\Desktop\Projeto FEM\Resultados Abaqus\';
inpNome = 'Viguinha.inp';
    
%Output
caminhoOutput = 'C:\Users\Wagner\Desktop\Projeto FEM\FEM-matlab\Arquivos_Saída\';
Unome = 'Deslocamentos_Nodais.txt';
Tnome = 'Tensão_elemento.txt';
Defnome =  'Desformacao_elemento.txt';

%Full path
INPfile = [caminhoInput inpNome];  


%% Definição do material
E = 2e5;
v = 0.3;
Cd = Celi(E,v);

%% Definições do tipo de Elemento

ngl=2;
% NnosElemento = 3;  

%% Definição da Malha

% [Ncoord,Nconec] = LeMalha(CaminhoArquivoNo,CaminhoArquivoElem);
    [Ncoord,Nconec] = leINP(INPfile);
 
     Ncoord(2:end) = 10*Ncoord;      
 
    

    Nnos = size(Ncoord,1); 

% Condições de contorno 
 
    % Matriz de deslocamentos nodais
    %  % Nno   U   GL (x=1, y=2)
    
    xmin=min(Ncoord(:,2)); % se eu soubesse a priori seria melhor
    Set = NodePosFinder(Ncoord,xmin);
    
    Mcc = set2Mcc(Set,0,1,[]);
    Mcc = set2Mcc(Set,0,2,Mcc);

    % Matriz de forcas nodais
         
    xmax=max(Ncoord(:,2)); % se eu soubesse a priori seria melhor
    Set2 = NodePosFinder(Ncoord,xmax);
    
    Fface= -10;
    f = Fface/size(Fface,1) ;
    
    Mfn = set2Mcc(Set2,f,2,[]);
%     Mfn = set2Mcc(Set2,f,2,Mfn);         
         
%% Processamento  

% Declaração inicial de Variaveis

Kglobal = zeros(ngl*Nnos);
F = zeros(ngl*Nnos,1);

% Reorganiza a matriz de coordenadas nodais (numeração crescente)
    SNcoord = sortrows(Ncoord);
    Mcc = sortrows(Mcc);
    
% Assembly da matriz de rigidez global
% AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO
    Kglobal = AssemblyDaGlobal2(Nconec,SNcoord,Kglobal,Cd);
    
    aa=eigs(Kglobal);

% Assembly do vetor de forças

for i=1:size(Mfn,1)  
   F(2*(Mfn(i,1)-1) + Mfn(i,3)) = Mfn(i,2); 
end
 
% Eliminação de linhas/colunas
 
[Kdel,Fdel] = constringeK (Kglobal,F,Mcc,ngl);
 
 % Calculo dos deslocamentos
 
 U = Kdel  \ Fdel ;
 
 %% Pós processamento
 % AQUI ATUALIZAR PARA O GL
% Reconstruindo o vetor de deslocamentos
   Ufinal = U;
   for L = 1:size(Mcc,1)
      glGlobal= Mcc(L,1)*ngl-2 +  Mcc(L,3);
      Ufinal = [Ufinal(1:glGlobal-1) ;   Mcc(L,2) ; Ufinal(glGlobal:end)];
   end

 % Coordenadas nodais deslocadas
 % AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO
   DefNcoor = defCoord(SNcoord,Ufinal);

 % Calculo de deformações
% AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO
%    MDef = DefLin(Nconec,SNcoord,Ufinal);
 
 % Calculo de tensões
 % AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO
%    Mtensao = CalcTensao(Cd,MDef);  
 % AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO  
%    VM = vonMises(Mtensao);
 % Calculo de Reações
 
   Ffinal = Kglobal*Ufinal; % Não é a maneira melhor mas é simples. 
  
   
 %% Plot
 % AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO
    plotDefIndef(SNcoord, Nconec,DefNcoor);
%     
%     plotMap(Mtensao(:,2),DefNcoor,Nconec); title('\sigma _{xx}');
%     plotMap(MDef(:,2),DefNcoor,Nconec); title('\epsilon _{xx}');
%     plotMap(VM(:,2),DefNcoor,Nconec);  title('Von Mises');
    
%% Saida de dados  
% AQUI PRECISA DEPENDER DO TIPO DE ELEMENTO
%     escreveDeslocamento(Ufinal,[caminhoOutput Unome]);
%     escreveTensao(Mtensao,[caminhoOutput Tnome]);
%     escreveDeformacao(MDef,[caminhoOutput Defnome]);

      
   